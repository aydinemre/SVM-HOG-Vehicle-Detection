#include <iostream>
#include <opencv2/opencv.hpp>
#include "Constants.h"
#define EXTENSION ".png"
#define PATH "./DataSet/RawDataBack/"

using namespace cv;
using namespace std;

Mat original;
Mat frame;
Mat gray;
Mat background; // fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractorMOG2> pMOG2; // MOG2 Background subtractor
char keyboard; // input from keyboard
String filename = "0";

void processVideo(const char *videoFilename);

int main(void){

    // Create window.
    namedWindow("Foreground");
    //namedWindow("FG Mask");

    // create Background Subtractor objects
    pMOG2 = createBackgroundSubtractorMOG2(); // MOG2 Approach
    pMOG2->setDetectShadows(false);
    pMOG2->setNMixtures(3);
    pMOG2->setVarThreshold(40);
    pMOG2->setShadowThreshold(200);
    processVideo(fileConstants::INPUT_VIDEO_FILE.c_str());

    destroyAllWindows();

    return 1;
}



void processVideo(const char *videoFilename) {
    int mod = 0;
    VideoCapture capture(videoFilename);

    if (!capture.isOpened()) {
        cerr << "Unable to open video file: " << videoFilename << endl;
        exit(EXIT_FAILURE);
    }

    keyboard = -1;
    while (keyboard != 'q' && keyboard != 27) {
        // read the current frame
        if (!capture.read(original)) {
            cerr << "Unable to read next frame" << endl;
            cerr << "Exiting..." << endl;
            exit(EXIT_FAILURE);
        }

        if (mod == -1) {
            // Eleminate ingoing traffic and far away cars
            for (int pi = 0; pi < original.rows; ++pi)
                for (int pj = 0; pj < original.cols; ++pj)
                    if (pj > original.cols / 2 || pi < original.rows / 2) {
                        original.at<Vec3b>(pi, pj)[0] = 0;
                        original.at<Vec3b>(pi, pj)[1] = 0;
                        original.at<Vec3b>(pi, pj)[2] = 0;
                    }
            // Copy to
            original.copyTo(frame);

            pMOG2->apply(frame, background);

            erode(background, background, getStructuringElement(MORPH_ELLIPSE, Size(7, 7)));
            dilate(background, background, getStructuringElement(MORPH_ELLIPSE, Size(57, 57)));

            for (int i = 0; i < background.rows; ++i) {
                for (int j = 0; j < background.cols; ++j) {
                    if (background.at<uchar>(i, j) == 0) {
                        frame.at<Vec3b>(i, j)[0] = 0;
                        frame.at<Vec3b>(i, j)[1] = 0;
                        frame.at<Vec3b>(i, j)[2] = 0;
                    }
                }
            }

            vector<vector<Point>> contours;
            cvtColor(frame, gray, COLOR_RGB2GRAY);
            findContours(gray, contours, RETR_EXTERNAL, CHAIN_APPROX_SIMPLE);


            for (int i = 0; i < contours.size(); ++i) {
                Rect rect = boundingRect(contours.at(i));
                rectangle(frame, rect, Scalar(0, 255, 0), 2);
                Mat data = original(rect);
                putText(frame, to_string(i), Point(rect.x, rect.y), FONT_HERSHEY_SCRIPT_COMPLEX, 3, Scalar(255, 0, 0));
            }

            resize(frame, frame, Size(640, 480));
            resize(background, background, Size(640, 480));
            imshow("Foreground", frame);
            //imshow("FG Mask",background);
            keyboard = (char) waitKey(0);
            if (keyboard - 48 >= 0 && keyboard - 48 < contours.size()) {
                cerr << (int) keyboard << endl;
                Rect rect = boundingRect(contours.at(keyboard - 48));
                rectangle(frame, rect, Scalar(0, 255, 0), 2);
                Mat data = original(rect);
                imwrite(PATH + filename + EXTENSION, data);
                filename = to_string(atoi(filename.c_str()) - 1);
            }
            if (keyboard == 'e')
                filename = to_string(atoi(filename.c_str()) + 1);

        } else{
            resize(original,original,Size(640,480));
            imshow("Foreground", original);
            keyboard = (char) waitKey(10);
        }
        keyboard == ' ' ? mod = 0 : mod = -1;

    }

    // delete capture object
    capture.release();
}